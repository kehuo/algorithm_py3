# @File: answer.py
# @Author: Kevin Huo
# @LastUpdate: 2/27/2020 8:22 PM

"""
许多有用的算法在结构上是递归的: 为了解决一个给定的问题, 算法一次或多次地调用自己, 以此解决紧密相关的若干个子问题.

这种算法典型地遵循分治法的思想: 将原问题分解为几个规模较小, 但类似于原问题的子问题, 递归地求解这些子问题, 然后再合并这些子问题
的解, 来建立原问题的解.

分治模式在每层递归时, 都有3个步骤:
    1. 分解: 分解原问题为若干子问题, 这些子问题是原问题的规模较小的实例.
    2. 解决: 解决这些子问题, 递归地求解各个子问题. 并且如果当子问题的规模足够小, 则直接求解.
    3. 合并: 合并这些子问题的解, 构成原问题的最终的解.

示例: "归并排序算法" -- 该算法完全遵循分治模式, 直观上其操作如下:
    1. 分解: 分解待排序的 n 个元素的序列, 分解成各有 n/2 个元素的 2 个子序列.
    2. 解决: 使用归并排序, 递归地排序 2 个子序列
    3. 合并: 合并 2 个已经排序的子序列, 从而产生最终排序的序列.

该示例中需要注意的部分:
    1. 当待排序的序列长度为 1 时, 递归达到 "基准条件", 并开始回升, 在这种情况下不要做任何工作, 因为长度为1的每个序列均已排好序.
    2. 该算法的关键是 "合并" 步骤中, 对已排序完成的 2 个序列的合并操作. 我们通过调用一个辅助过程 Merge(A, p, q, r) 来完成合并.
        其中 A 是数组
        p / q / r 是数组A的3个下标, 并且 p <= q < r
    3. 该过程中假设 A[p...q] 和 A[q...r] 都已经排好序
"""


def merge():
    """
    时间复杂度: O(n), 其中 n = r - p + 1是待合并元素的总数
    """
    pass