# @File: 4.py
# @Author: Kevin Huo
# @Date: 2020/4/12


def numOfWays(n: int) -> int:
    """
    https://leetcode-cn.com/contest/weekly-contest-184/problems/number-of-ways-to-paint-n-x-3-grid/

    二叉树, 保证对于每一个节点, 有2个子节点, 且2个子节点的值要满足2个条件:
    1. 不能等于父节点的值
    2. 不能同级, 且相邻的子节点的值

    示例
    ----
    ######## n=1 ########
    grid = [
        [a00, a01, a02]
    ]

    3种颜色 r/b/g

    **因为每种颜色开头的情况都相同, 所以只要计算出其中一个颜色是第一个的情况, 再x3就是最终返回的结果. 比如:
    以红色r开头一共有4种情况:
    r - b - r
    r - b - g
    r - g - r
    r - g - b

    那么最终结果就是 r的4种情况 + b的4种情况 + g的4种情况

    ########### n=2(复杂多了, 因为上下左右相邻的块都不能同色) ##############
    grid = [
        [a00, a01, a02],
        [a11, a11, a12]
    ]

    以红色开头为例 (斜着看就是一个二叉树), 我会按照 "先左后右, 深度优先" 的节点遍历顺序, 去计算所有情况:
    情况1 - (左上角的r是根节点, 它有2个子节点, b 和 b)
    r - b - r
    |   |   |
    b - r - b

    情况2 - (按照 先左后右 的原则, 先将根结点a[0][0] 的 左节点 a[1][0] 变一下. 因为根结点是r, 所以左节点只能从b变成g)
    注意, 这里每变一下, 效果类似于 build_max_heapify, 下面所有的子节点都要跟着检查一遍.
    r - b - r
    |   |   |
    g - r - b

    情况3 - (按照深度优先), 遍历g节点a[1][0]的子节点. 因为这个节点只有右节点a[1][1], 没有左节点a[1][0], 所以
    当前节点就是g的右子节点a[1][1] (值是r).
    [操作] - 按照 r/b/g顺序, 依次尝试变化 a[1][1]:
    <1> 自己是r, 所以r不用考虑, 只考虑 b/g 2个情况:
    是否可以变成b - 检查自己的相邻节点a[0][1] 和 a[1][0](也就是自己的父节点), 它们的颜色是 [b, g], 所以不能变化
    [结果] - 当前节点不做任何变化, 直接到当前节点a[1][1]的下一个子节点(先左后右)
    r - b - g
    |   |   |
    g - r - b

    情况4 - 当前是 a[1][1] 的子节点,
    r - g - g
    |   |   |
    b - r - b
    """

